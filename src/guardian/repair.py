from pathlib import Path
from typing import List, Tuple, Union, Optional
import os
import datetime
from dataclasses import dataclass


@dataclass
class RepairAction:
    """Class representing a repair action that can be performed"""

    action_type: str
    source_commit: str
    target_branch: str = "master"
    description: str = ""


def generate_repair_script(
    repo_path: Union[str, Path],
    actions: List[RepairAction],
    output_dir: Optional[Path] = None,
) -> Tuple[bool, str, Path]:
    """
    Generate a script to repair a git repository

    Args:
        repo_path: Path to the git repository
        actions: List of repair actions to perform
        output_dir: Directory to save the script

    Returns:
        Tuple of (success, message, script_path)
    """
    repo_path = Path(repo_path)
    if output_dir is None:
        output_dir = repo_path

    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    script_path = output_dir / f"repair_{timestamp}.sh"

    try:
        with open(script_path, "w") as f:
            f.write("#!/bin/bash\n\n")
            f.write("# Repair script generated by Repo guardian\n")
            f.write(
                f"# Creation date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"  # NOQA
            )
            f.write(f"# Repository: {repo_path}\n\n")

            f.write("set -e\n\n")
            f.write(f"cd {repo_path}\n\n")

            for i, action in enumerate(actions):
                f.write(
                    f"echo 'Step {i+1}: {action.description or action.action_type} {action.source_commit}'\n"  # NOQA
                )

                if action.action_type == "cherry-pick":
                    f.write(f"git cherry-pick {action.source_commit}\n\n")
                elif action.action_type == "rebase":
                    f.write(
                        f"git rebase --onto {action.target_branch} {action.source_commit}^ {action.source_commit}\n\n"  # NOQA
                    )
                elif action.action_type == "reset":
                    f.write(f"git reset --hard {action.source_commit}\n\n")

        os.chmod(script_path, 0o755)
        return True, f"Repair script created at {script_path}", script_path

    except Exception as e:
        return False, f"Failed to create repair script: {e}", script_path


def generate_rebase_todo(
    repo_path: Union[str, Path], commits: List[str], output_dir: Optional[Path] = None
) -> Tuple[bool, str, Path]:
    """
    Generate a rebase todo file for interactive rebase

    Args:
        repo_path: Path to the git repository
        commits: List of commit SHAs to include in the rebase
        output_dir: Directory to save the todo file (defaults to repo_path)

    Returns:
        Tuple of (success, message, todo_path)
    """
    repo_path = Path(repo_path)
    if output_dir is None:
        output_dir = repo_path

    todo_path = output_dir / "rebase-todo.txt"

    try:
        with open(todo_path, "w") as f:
            f.write("# Rebase todo file generated by Repo Guardian\n")
            f.write("# Commands:\n")
            f.write("#  p, pick <commit> = use commit\n")
            f.write("#  r, reword <commit> = use commit, but edit the commit message\n")
            f.write("#  e, edit <commit> = use commit, but stop for amending\n")
            f.write(
                "#  s, squash <commit> = use commit, but meld into previous commit\n"
            )
            f.write(
                "#  f, fixup <commit> = like 'squash', but discard this commit's message\n"  # NOQA
            )
            f.write("#  d, drop <commit> = remove commit\n")
            f.write("#\n")

            for commit in commits:
                f.write(f"pick {commit}\n")

        return True, f"Rebase todo file created at {todo_path}", todo_path

    except Exception as e:
        return False, f"Failed to create rebase todo file: {e}", todo_path


def create_cherry_pick_script(
    repo_path: Union[str, Path],
    commits: List[str],
    target_branch: str = "master",
    output_dir: Optional[Path] = None,
) -> Tuple[bool, str, Path]:
    """
    Generate a script for cherry-picking commits onto a target branch

    Args:
        repo_path: Path to the git repository
        commits: List of commit SHAs to cherry-pick
        target_branch: Branch to cherry-pick onto
        output_dir: Directory to save the script

    Returns:
        Tuple of (success, message, script_path)
    """
    actions = [
        RepairAction(
            action_type="cherry-pick",
            source_commit=commit,
            target_branch=target_branch,
            description=f"Cherry-pick commit {commit[:8]} onto {target_branch}",
        )
        for commit in commits
    ]

    checkout_action = RepairAction(
        action_type="checkout",
        source_commit=target_branch,
        target_branch=target_branch,
        description=f"Switch to target branch {target_branch}",
    )

    actions.insert(0, checkout_action)

    return generate_repair_script(repo_path, actions, output_dir)


def create_rebase_script(
    repo_path: Union[str, Path],
    branch: str,
    onto_branch: str = "master",
    interactive: bool = False,
    output_dir: Optional[Path] = None,
) -> Tuple[bool, str, Path]:
    """
    Generate a script for rebasing a branch onto another branch

    Args:
        repo_path: Path to the git repository
        branch: Branch to rebase
        onto_branch: Branch to rebase onto
        interactive: Whether to generate an interactive rebase script
        output_dir: Directory to save the script (defaults to repo_path)

    Returns:
        Tuple of (success, message, script_path)
    """
    repo_path = Path(repo_path)
    if output_dir is None:
        output_dir = repo_path

    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    script_path = output_dir / f"rebase_{timestamp}.sh"

    try:
        with open(script_path, "w") as f:
            f.write("#!/bin/bash\n\n")
            f.write("# Rebase script generated by Repo Guardian\n")
            f.write(
                f"# Creation date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"  # NOQA
            )
            f.write(f"# Repository: {repo_path}\n\n")

            f.write("set -e\n\n")
            f.write(f"cd {repo_path}\n\n")

            f.write(f"echo 'Rebasing {branch} onto {onto_branch}'\n")

            if interactive:
                f.write(f"git rebase -i {onto_branch} {branch}\n")
            else:
                f.write(f"git checkout {branch}\n")
                f.write(f"git rebase {onto_branch}\n")

        os.chmod(script_path, 0o755)
        return True, f"Rebase script created at {script_path}", script_path

    except Exception as e:
        return False, f"Failed to create rebase script: {e}", script_path


def create_reset_recovery_script(
    repo_path: Union[str, Path],
    target_commit: str,
    create_backup_branch: bool = True,
    output_dir: Optional[Path] = None,
) -> Tuple[bool, str, Path]:
    """
    Generate a script to recover using git reset to a specific commit

    Args:
        repo_path: Path to the git repository
        target_commit: Commit to reset to
        create_backup_branch: Whether to create a backup branch before resetting
        output_dir: Directory to save the script (defaults to repo_path)

    Returns:
        Tuple of (success, message, script_path)
    """
    repo_path = Path(repo_path)
    if output_dir is None:
        output_dir = repo_path

    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    script_path = output_dir / f"reset_recovery_{timestamp}.sh"

    try:
        with open(script_path, "w") as f:
            f.write("#!/bin/bash\n\n")
            f.write("# Reset recovery script generated by Repo Guardian\n")
            f.write(
                f"# Creation date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"  # NOQA
            )
            f.write(f"# Repository: {repo_path}\n\n")

            f.write("set -e\n\n")
            f.write(f"cd {repo_path}\n\n")

            f.write("CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)\n")

            if create_backup_branch:
                f.write(
                    f"echo 'Creating backup branch backup_{timestamp} from current state'\n"  # NOQA
                )
                f.write(f"git branch backup_{timestamp}\n\n")

            f.write(f"echo 'Resetting $CURRENT_BRANCH to commit {target_commit}'\n")
            f.write(f"git reset --hard {target_commit}\n\n")

            f.write("echo 'Recovery complete'\n")
            f.write(
                "echo 'To push this reset, use: git push --force-with-lease origin $CURRENT_BRANCH'\n"  # NOQA
            )

        os.chmod(script_path, 0o755)
        return True, f"Reset recovery script created at {script_path}", script_path

    except Exception as e:
        return False, f"Failed to create reset recovery script: {e}", script_path
